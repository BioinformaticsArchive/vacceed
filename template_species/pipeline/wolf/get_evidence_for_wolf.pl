#!/usr/bin/perl
use strict;
#use warnings;

#get the command line arguments
my $input_file = $ARGV [0];
my $evidence_dir =  $ARGV [1] . "/";
my $resource = $ARGV [2];
my $split_char = $ARGV [3];
my $id_info = $ARGV [4];
my $evd_headers = $ARGV [5];
my $ignore_lines = $ARGV [6];
my $proteome_dir =  $ARGV [7] . "/";
my $proteome_fasta = $ARGV [8];
my $prot_id_prefix = $ARGV [9];


## hard coding
my $output_file = $evidence_dir . $resource . "_evd";
my $proteome_file = $proteome_dir . "tmp_" . $proteome_fasta;


#extract 1: Which column in the input line contains the identifier, the position of the id in the identifier, the separating character betweens parts of the identifier.
my ($id_col,$id_pos,$id_sep) = split (',',$id_info);

#Global variables

#create hashes
my %h_proteome_ids;
my %h_evidence;

#Open debug file
#open DEBUG_FILE,'>debug.txt';

#File handling
open INPUT_FILE,$input_file ;
open PROTEOME_FILE,$proteome_file;
open OUTPUT_FILE,'>' . $output_file;

print OUTPUT_FILE "ID," . $evd_headers . "\n";  


#LOOP 
while (defined (my $line = <PROTEOME_FILE>)) {
	
	if ($line =~ m/>$prot_id_prefix\|(\w+)/) { 
		$h_proteome_ids {$1} = 0;
	}
}

  

#LOOP 
while (defined (my $line = <INPUT_FILE>)) {

	#reset variables
	my $col_count = 0;
	my $id;
	my @evidence = ();

	#Check for #  or blank line
	if (($line =~ m/^#/) || ($line =~ m/^\s*$/)) { next;}
	
	$line = &trim ($line);
	
	#sp|A5JYQ9|VMA21_CAEEL plas 28, extr_plas 15.5
	my ($line_input,$dum1) = split ('\s+',$line);
	
	$id = &get_ID ($line_input);
			
	if ($id eq "0") {
		print "ERROR: ID not found on line $line\n";
		exit 1;
	}
	#get the rest of the line
	$line_input = quotemeta $line_input;
	$line =~ m/$line_input\s+(.+)/;
	
	my $evidence_out = &parse_line_input ($1);
				
	$h_evidence {$id} = $id . "," . $evidence_out;
			
} #end of LINE:while


foreach my $id (sort keys %h_proteome_ids) {

	if (&check_for_empty_string ($h_evidence {$id})) {

		#This means that no output was generated by WOLF for this protein ID
		 print OUTPUT_FILE $id . ",0.0,NONE\n"

	} else {

		print OUTPUT_FILE $h_evidence {$id} . "\n";
	}
}	

#####################SUB ROUTINES ################################

# sub-routine to remove  whitespace from the start and end of the string
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}


#Check for empty string
sub  check_for_empty_string ($)
{
	my $string = shift;
	if ($string =~ m/^\s*$/) {
		return 1;
	} else {
		return 0;
	}
}

## Get the ID
sub  get_ID ($)
{
	my $id_line = shift;
	my $split_count = 0;
	
	my @id_input = split ($id_sep,$id_line);
		
	foreach my $col (@id_input) {
		
		$split_count++;

		if ($split_count == $id_pos) {
			return $col;
		}
	}

	return 0;
}


## Get the ID
sub  ignore_line ($)
{
	my $line = shift;
		
	my @ignore_input = split (',',$ignore_lines);
		
	foreach my $ignore (@ignore_input) {
	
		if ($line =~ m/^$ignore/) {
			return 1;
		}
	}

	return 0;
}

sub parse_line_input ($)
{
	my $line = shift;

	#Global variables
	my $type;
	my $score = 0;
	my $plas_score = 0;
	my $extr_score = 0;
	my $duel_plas_score = 0;
	my $duel_extr_score = 0;

	my @line_input = split (',',$line);

	foreach my $split (@line_input) {

		#trim the split
		$split = &trim ($split);

		if ($split =~ m/^plas\s*(\d+).(\d)/) {
			$plas_score =  $1 . "." . $2;
		} elsif ($split =~ m/^plas\s*(\d+)/) {
			$plas_score =  $1 . ".0";
		} elsif ($line =~ m/^extr\s*(\d+).(\d)/) {
			$extr_score =  $1 . "." . $2;
		} elsif ($line =~ m/^extr\s*(\d+)/) {
			$extr_score =  $1 . ".0";
		### Possible membrane and secreted
		} elsif ($split =~ m/plas_extr\s*(\d+).(\d)/) {
			$duel_plas_score =  $1 . "." . $2;
			$duel_extr_score =  $1 . "." . $2;
		} elsif ($split =~ m/plas_extr\s*(\d+)/) {
			$duel_plas_score =  $1 . ".0";
			$duel_extr_score =  $1 . ".0";
		} elsif ($split =~ m/extr_plas\s*(\d+).(\d)/) {
			$duel_plas_score =  $1 . "." . $2;
			$duel_extr_score =  $1 . "." . $2;
		} elsif ($split =~ m/extr_plas\s*(\d+)/) {
			$duel_plas_score =  $1 . ".0";
			$duel_extr_score =  $1 . ".0";
		### Possible duel locations
		} elsif ($split =~ m/plas_\s*(\d+).(\d)/) {
			$duel_plas_score =  $1 . "." . $2;
		} elsif ($split =~ m/plas_\s*(\d+)/) {
			$duel_plas_score =  $1 . ".0";
		} elsif ($line =~ m/extr_\w+:\s*(\d+).(\d)/) {
			$duel_extr_score =  $1 . "." . $2;
		} elsif ($line =~ m/extr_\w+:\s*(\d+)/) {
			$duel_extr_score =  $1 . ".0";
		} elsif ($split =~ m/_plas\s*(\d+).(\d)/) {
			$duel_plas_score =  $1 . "." . $2;
		} elsif ($split =~ m/_plas\s*(\d+)/) {
			$duel_plas_score =  $1 . ".0";
		} elsif ($line =~ m/_extr\w+:\s*(\d+).(\d)/) {
			$duel_extr_score =  $1 . "." . $2;
		} elsif ($line =~ m/_extr\w+:\s*(\d+)/) {
			$duel_extr_score =  $1 . ".0";
		}
		
	}

	# get the highest score
	if ($duel_extr_score > $extr_score) {
		$extr_score = $duel_extr_score;
	}

	if ($duel_plas_score > $plas_score) {
		$plas_score = $duel_plas_score;
	}
		
	if ($extr_score > $plas_score) {
		$score = $extr_score;
		$type = "Secreted";
	}elsif ($extr_score < $plas_score)  {
		$score = $plas_score;
		$type = "membrane";
	}elsif (($extr_score == $plas_score) && ($extr_score !=0) && ($plas_score != 0))  {
		$score = $extr_score;
		$type = "membrane_and_secreted";
	}else {
		$type = "not_screted_or_membrane";
	}

	return $score . "," . $type; 

}
